#include <furi.h>

#include <gui/gui.h>

/* generated by fbt from .png files in images folder */
#include <yuricable_icons.h>

#include <yuricable_structs.c>

#define TAG "YuriCable"


static void demo_input_callback(InputEvent* input_event, FuriMessageQueue* queue) {
    furi_assert(queue);
    Event event = {.type = EventTypeKey, .input = *input_event};
    furi_message_queue_put(queue, &event, FuriWaitForever);
}

static void demo_gpio_fall_callback(FuriMessageQueue* queue) {
    UNUSED(queue);

    FURI_LOG_I(TAG, "Trigger Interrupt");
}

int32_t yuricable_app(void* p) {
    UNUSED(p);

    FURI_LOG_I(TAG, "Starting YuriCable App");

    FuriMessageQueue *queue = furi_message_queue_alloc(8, sizeof(Event));

    furi_hal_gpio_init(&gpio_ext_pc3, GpioModeInterruptFall, GpioPullUp, GpioSpeedVeryHigh);

    furi_hal_gpio_add_int_callback(&gpio_ext_pc3, demo_gpio_fall_callback, queue);

    ViewPort* view_port = view_port_alloc();
    view_port_input_callback_set(view_port, demo_input_callback, queue);

    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    Event event;
    bool processing = true;
    do {
        if(furi_message_queue_get(queue, &event, 1000) == FuriStatusOk) {
            FURI_LOG_I(TAG, "Got event type: %d", event.type);
            switch(event.type) {
                case EventTypeKey:
                    // Short press of back button exits the program.
                    if(event.input.type == InputTypeShort && event.input.key == InputKeyBack) {
                        FURI_LOG_I(TAG, "Short-Back pressed. Exiting program.");
                        processing = false;
                    }
                    break;
                default:
                    break;
            }
        }
    } while(processing);

    furi_hal_gpio_remove_int_callback(&gpio_ext_pc3);

    furi_hal_gpio_init(&gpio_ext_pc3, GpioModeOutputOpenDrain, GpioPullNo, GpioSpeedLow);
    furi_hal_gpio_write(&gpio_ext_pc3, true);

    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_record_close(RECORD_GUI);
    furi_message_queue_free(queue);

    return 0;
}
